<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随缘</title>
  
  <subtitle>柊沐的咸鱼板</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zsgdyf.github.io/"/>
  <updated>2020-05-16T08:27:50.680Z</updated>
  <id>https://zsgdyf.github.io/</id>
  
  <author>
    <name>zsgdyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日语学习笔记（一） -- 「は」和「が」的区别</title>
    <link href="https://zsgdyf.github.io/archives/5aefdc5d.html"/>
    <id>https://zsgdyf.github.io/archives/5aefdc5d.html</id>
    <published>2019-06-24T12:17:24.000Z</published>
    <updated>2020-05-16T08:27:50.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「は」と「が」の区別"><a href="#「は」と「が」の区別" class="headerlink" title="「は」と「が」の区別"></a>「は」と「が」の区別</h1><h2 id="强调的部分不同"><a href="#强调的部分不同" class="headerlink" title="强调的部分不同"></a>强调的部分不同</h2><p>「は」是强调「は」后面的部分，而「が」是强调「が」前面的部分。</p><a id="more"></a><p>例如：</p><p>「A　は　B　です。」和「A　が　B　です。」</p><p>前句强调的是 B ，而后句强调的是 A。</p><p>实际语境看一下：</p><blockquote><p>-- お国はどちらですか？</p><p>-- 私　は　日本人です。（强调是「日本人」）</p></blockquote><p>和</p><blockquote><p>-- 誰か日本人ですか？</p><p>-- 私　が　日本人です。（强调「我」是）</p></blockquote><p>的区别。</p><p>来源视频：<a href="https://www.bilibili.com/video/av33914825" target="_blank" rel="noopener">日本学霸给你讲解は和が的微妙区别</a></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=33914825&cid=59393368&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="新信息和旧信息"><a href="#新信息和旧信息" class="headerlink" title="新信息和旧信息"></a>新信息和旧信息</h2><p>在标日P228页中对于「～が～です」的语法讲解中，提到「新信息做主语时用『が』来表示」，而在使用「A　は　B　です。」的表达的时候，A 是旧信息，B是新信息。</p><p>书上给出的例子是：</p><blockquote><p>山田先生　は　どの方ですか？</p><p>-- 山田先生　は　あの方です。</p><p>-- あの方　が　山田先生です。</p></blockquote><p>并且还讲到，叙述直接观察到的某个事物，而不是作为话题在谈论这个事物时，使用「『名词』が『动词』」的形式，因为这里也同样是新信息在做主语。</p><p>例如：</p><blockquote><p>子供　が　公園で遊んでいます。</p><p>バス　が　来ました。</p></blockquote><p>以及我们熟悉的</p><blockquote><p>天気がいいです。</p></blockquote><p>所以按照这个观点，标日解释了为何「何」「誰」「何処」「何時」疑问词做主语时不能用「は」，只能用「が」，因为这些词不能表示旧信息。</p><p>所以我们只能说</p><blockquote><p>誰　が　いますか？</p></blockquote><p>和</p><blockquote><p>何　が　すきですか？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;「は」と「が」の区別&quot;&gt;&lt;a href=&quot;#「は」と「が」の区別&quot; class=&quot;headerlink&quot; title=&quot;「は」と「が」の区別&quot;&gt;&lt;/a&gt;「は」と「が」の区別&lt;/h1&gt;&lt;h2 id=&quot;强调的部分不同&quot;&gt;&lt;a href=&quot;#强调的部分不同&quot; class=&quot;headerlink&quot; title=&quot;强调的部分不同&quot;&gt;&lt;/a&gt;强调的部分不同&lt;/h2&gt;&lt;p&gt;「は」是强调「は」后面的部分，而「が」是强调「が」前面的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="日语" scheme="https://zsgdyf.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>前端常见知识点（四）</title>
    <link href="https://zsgdyf.github.io/archives/4adfd4ff.html"/>
    <id>https://zsgdyf.github.io/archives/4adfd4ff.html</id>
    <published>2019-03-08T15:58:53.000Z</published>
    <updated>2020-05-16T08:27:50.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>IE 的事件流叫做「事件冒泡」，是指事件开始的时候是由最具体的元素（文档中嵌套层次最深的那个节点），或者说，是距离事件发生的最近的节点接受，然后<strong>逐级向上</strong>传播到较为不具体的节点（<code>document</code>）。</p><p>而 Netscape （网景）团队提出的另外一种事件流叫做「事件捕获」，与事件冒泡刚好相反，事件捕获的思想是不太具体的节点应该更先接收到事件，最具体的节点最后接收到事件。</p><a id="more"></a><h2 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h2><p>「DOM 2 级事件」规定，事件流包括三个阶段：<strong>事件捕获</strong>、<strong>事件处理</strong>和<strong>事件冒泡</strong>阶段，并且在事件捕获的阶段，实际发生事件的节点不会接收到事件，事件从<code>document</code>到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>后就停止了，之后在目标节点上发生，并在事件处理中被看成是冒泡阶段的一部分，之后在冒泡阶段中，事件又传播回<code>document</code>。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件对象<code>event</code>是一个 在触发 DOM 上的某个事件时产生的，包含所有与该事件有关的信息的 对象。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>BUTTON<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span></span><br><span class="line"><span class="javascript">            btn.onclick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(event)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击按钮，然后在 Chrome 浏览器的控制台里我们就可以看到<code>event</code>对象的所有信息了。比如事件的类型<code>event.type</code>（<code>click</code>），事件的目标（即导致事件产生的元素）<code>event.target</code>（<code>button#btn</code>）等。合理利用事件对象的这些属性帮助我们提升不少工作效率，例如使用<code>target</code>属性完成事件委托。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>在「红宝书」中有这么一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"links"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go Somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do doSomething<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> links = <span class="built_in">document</span>.getElementById(<span class="string">'links'</span>)</span></span><br><span class="line"><span class="javascript">            links.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> target = event.target</span></span><br><span class="line"><span class="javascript">                <span class="keyword">switch</span> (target.id) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">case</span> <span class="string">'goSomewhere'</span>:</span></span><br><span class="line"><span class="javascript">                        location.href = <span class="string">'anotherPage.html'</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">case</span> <span class="string">'doSomething'</span>:</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.title = <span class="string">'The Title Changed'</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">case</span> <span class="string">'greet'</span>:</span></span><br><span class="line"><span class="javascript">                        alert(<span class="string">'Hello!'</span>)</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">break</span></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子里，我们使用事件委托只为<code>&lt;ul&gt;</code>元素添加了一个<code>onclick</code>事件处理程序，由于事件冒泡的特点，<code>&lt;ul&gt;</code>就可以处理它的所有子节点<code>&lt;li&gt;</code>的事件，这样子，比取得每一个<code>&lt;li&gt;</code>元素并分别对齐添加事件要方便的多。</p><p>并且这种方式因为只取得了一个 DOM 元素，只添加了一个事件处理程序，所以占用的内存更少，所花的时间也更少。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;p&gt;IE 的事件流叫做「事件冒泡」，是指事件开始的时候是由最具体的元素（文档中嵌套层次最深的那个节点），或者说，是距离事件发生的最近的节点接受，然后&lt;strong&gt;逐级向上&lt;/strong&gt;传播到较为不具体的节点（&lt;code&gt;document&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;而 Netscape （网景）团队提出的另外一种事件流叫做「事件捕获」，与事件冒泡刚好相反，事件捕获的思想是不太具体的节点应该更先接收到事件，最具体的节点最后接收到事件。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="前端" scheme="https://zsgdyf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端常见知识点（三）</title>
    <link href="https://zsgdyf.github.io/archives/fdf2cd9a.html"/>
    <id>https://zsgdyf.github.io/archives/fdf2cd9a.html</id>
    <published>2019-03-07T06:49:40.000Z</published>
    <updated>2020-05-16T08:27:50.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>前面讲到闭包的时候，我们说闭包是「是指有权访问另一个函数<strong>作用域</strong>中的变量的函数」，那么所谓的「作用域」又是什么呢？</p><a id="more"></a><h2 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h2><p>先来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">greet() <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们在<code>greet</code>函数外部定义了一个变量<code>a</code>，函数<code>greet</code>首先在自己的<strong>作用域</strong>中查找变量<code>a</code>，没有找到后再在外部的全局<strong>作用域</strong>中查找，找到之后将其打印输出。</p><p>接下来是另外一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">'world!'</span></span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">greet() <span class="comment">// world!</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Hello!</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><p>在这段代码中，我们在<code>greet</code>函数内部定义了一个变量<code>b</code>，调用<code>greet</code>函数能够正常将其打印输出，但是当我们在外部直接输出变量<code>b</code>的时候却报错了，也就是说，在全局<strong>作用域</strong>里，变量<code>b</code>是未定义的。</p><p>于是我们知道，JavaScript 的<strong>作用域</strong>是通过<strong>函数</strong>来实现的，在函数<strong>内部</strong>定义的变量，在函数的<strong>外部</strong>是不可以访问的。</p><p>在 ES6 的<code>let</code>、<code>const</code>关键字提出来之前，JavaScript 的作用域只有两种：「全局作用域」和「函数（局部）作用域」。<strong>JavaScript 是没有「块作用域」的。</strong></p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>依旧是第一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">greet() <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><p>我们查找变量<code>a</code>的过程是：首先在函数<code>greet</code>的作用域中查找，之后到函数的上一层（这里是全局）作用域中查找，这样<strong>逐步向外</strong>查找的过程形成一个链条，就称作「作用域链」。</p><p>下面来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'window'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'outter'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">'inner'</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    inner() <span class="comment">// inner</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">outter() <span class="comment">// outter</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>如果把<code>inner</code>函数中的<code>a</code>的定义注释掉，那么<code>ineer()</code>的输出就是<code>outter</code>；如果再把<code>outter</code>函数中的<code>a</code>定义注释掉，那么三个输出就全都是<code>window</code>；这里的作用域链就是<code>inner</code>-&gt;<code>outter</code>-&gt;<code>window</code>（全局）。</p><h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>尽管在 JavaScript 中，作用域只有全局和局部（函数）两种，但是作用域链可能会在某些情况下得到加长。</p><blockquote><ol><li><code>try-catch</code>语句的<code>catch</code>块；</li><li><code>with</code>语句。</li></ol></blockquote><p>在「红宝书」中有一个 <code>with</code>语句的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debyg=true"</span></span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">var</span> url = href + qs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(buildUrl())</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>with</code>语句接受到的是<code>location</code>对象，因此其变量对象中就包含了<code>location</code>对象的所有属性和方法，而这个变量对象被临时添加到了作用域链的前端，作用域链就变成了：<code>location</code>对象-&gt;<code>buildUrl</code>的变量对象-&gt;<code>windows</code>全局对象，于是当在<code>with</code>语句中引用变量<code>href</code>时，实际引用的就是<code>location.href</code>。</p><p>至于<code>try-catch</code>语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    handleError(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>catch</code>语句来说，会创建一个包含着被抛出的错误对象的声明的新的变量对象，并将其置于作用域链的头部，当<code>catch</code>语句块的代码执行完，会移除该变量对象，销毁作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;前面讲到闭包的时候，我们说闭包是「是指有权访问另一个函数&lt;strong&gt;作用域&lt;/strong&gt;中的变量的函数」，那么所谓的「作用域」又是什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="前端" scheme="https://zsgdyf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端常见知识点（二）</title>
    <link href="https://zsgdyf.github.io/archives/b0ec6ec8.html"/>
    <id>https://zsgdyf.github.io/archives/b0ec6ec8.html</id>
    <published>2019-03-06T09:43:35.000Z</published>
    <updated>2020-05-16T08:27:50.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>根据「红宝书」中的描述，<strong>原型链</strong>是实现继承的主要方法。其原理是利用<strong>原型</strong>让一个引用类型继承另一个引用类型的属性和方法。</p><a id="more"></a><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'F'</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonname = <span class="string">"S"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 Father 实例，并将其赋给 Son.prototype</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonname</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son()</span><br><span class="line"><span class="built_in">console</span>.log(son1.getFatherName()) <span class="comment">// F</span></span><br></pre></td></tr></table></figure><p>上述代码实现了<code>Son</code>继承<code>Father</code>，其本质是重写<code>Son</code>的原型对象，并以<code>Father</code>的实例代之，这样，原本存在于<code>Father</code>实例中的属性和方法，现在也存在于<code>Son.prototype</code>中了。</p><p>同时的，<strong>所有函数的默认原型都是<code>Object</code>的实例</strong>，即可以看做是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father.prototype = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><p>这样我们就有了「<code>Son</code>的原型对象中包含着指向<code>Father</code>原型的指针，<code>Father</code>的原型对象中又包含着指向<code>Object</code>原型的指针」，如此递进，形成了实例与原型的链，这就是原型链的基本概念。</p><p>但是所谓的「原型对象」又是什么呢？</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>「红宝书」中说</p><blockquote><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则来为该函数创建一个<code>prototype</code>属性，这个属性指向函数的原型对象。</p><p>并且在默认情况下，所有的原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性是一个指向<code>prototype</code>属性所在函数的指针。</p></blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'F'</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.constructor <span class="comment">// function Father()</span></span><br></pre></td></tr></table></figure><p>倘若我们调用构造函数创建一个新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Father()</span><br></pre></td></tr></table></figure><p>那么该实例的内部就会包含一个指针（内部属性），指向构造函数的原型对象。</p><p>在某些地方（Chrome，Firefox），我们可以这样访问它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father.__proto__ <span class="comment">// Father.prototype</span></span><br><span class="line">father.__proto__.constructor <span class="comment">// function Father()</span></span><br></pre></td></tr></table></figure><p>并且，这个连接存在于实例与构造函数的<strong>原型对象</strong>之间，而不是实例与构造函数之间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;h2 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h2&gt;&lt;p&gt;根据「红宝书」中的描述，&lt;strong&gt;原型链&lt;/strong&gt;是实现继承的主要方法。其原理是利用&lt;strong&gt;原型&lt;/strong&gt;让一个引用类型继承另一个引用类型的属性和方法。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="前端" scheme="https://zsgdyf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端常见知识点（一）</title>
    <link href="https://zsgdyf.github.io/archives/80fa8210.html"/>
    <id>https://zsgdyf.github.io/archives/80fa8210.html</id>
    <published>2019-03-06T08:05:07.000Z</published>
    <updated>2020-05-16T08:27:50.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>常见的理解，用「红宝书」中的话说就是：<strong>闭包</strong>是指有权访问<strong>另一个函数作用域</strong>中的变量的<strong>函数</strong>。创建闭包的常见方式就是在一个函数内部创建另一个函数。</p><a id="more"></a><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greet = <span class="string">'Hello!'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(greet)</span><br><span class="line">    &#125;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line">greetFunc() <span class="comment">// greet</span></span><br></pre></td></tr></table></figure><p>在这段代码中，函数<code>foo()</code>成功打印出了在其父函数中定义的<code>greet</code>变量的值，这就形成了一个闭包。</p><h2 id="闭包有什么用？"><a href="#闭包有什么用？" class="headerlink" title="闭包有什么用？"></a>闭包有什么用？</h2><p>常见的理解，闭包一般用来「间接」访问一个变量，或者说，「隐藏」一个变量。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greet = <span class="string">'Hello!'</span></span><br><span class="line">    <span class="keyword">this</span>.getGreet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setGreet = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        greet = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> greetFunc()</span><br><span class="line"><span class="built_in">console</span>.log(foo.getGreet()) <span class="comment">// Hello!</span></span><br><span class="line">foo.setGreet(<span class="string">'Bonjour!'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(foo.getGreet()) <span class="comment">// Bonjour!</span></span><br></pre></td></tr></table></figure><p>这样，在<code>greetFunc()</code>函数外部，我们就可以通过<code>get</code>和<code>set</code>方法来访问函数内部的变量<code>greet</code>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h1&gt;&lt;h2 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h2&gt;&lt;p&gt;常见的理解，用「红宝书」中的话说就是：&lt;strong&gt;闭包&lt;/strong&gt;是指有权访问&lt;strong&gt;另一个函数作用域&lt;/strong&gt;中的变量的&lt;strong&gt;函数&lt;/strong&gt;。创建闭包的常见方式就是在一个函数内部创建另一个函数。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="前端" scheme="https://zsgdyf.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>C++ 解决八数码问题</title>
    <link href="https://zsgdyf.github.io/archives/8c98d183.html"/>
    <id>https://zsgdyf.github.io/archives/8c98d183.html</id>
    <published>2018-12-27T10:00:30.000Z</published>
    <updated>2020-05-16T08:48:03.801Z</updated>
    
    <content type="html"><![CDATA[<p>关于八数码问题，网上搜索一下就能有详细说明，在此不做赘述。</p><p>简单点说就是将类似下图所示的状态</p><div class="table-container"><table><thead><tr><th style="text-align:center">2</th><th style="text-align:center">8</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">6</td><td style="text-align:center">5</td></tr></tbody></table></div><p>通过与空格进行交换，达到类似如下所示的状态</p><div class="table-container"><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">6</td><td style="text-align:center">5</td></tr></tbody></table></div><p>在这个算法里空格当做数字 0 处理。</p><a id="more"></a><h1 id="算法整体思路"><a href="#算法整体思路" class="headerlink" title="算法整体思路"></a>算法整体思路</h1><p>将每一个九宫格当做一个状态，每次移动一个数字就会生成一个新的状态，若新状态与最终状态相等，则表示解找到。</p><p>从初始状态开始，可构造一棵状态生成树，遍历这棵生成树找到目标状态即可。</p><p><em>注意：八数码问题不是始终有解的，只有初始状态的逆序数与终了状态的逆序数奇偶性相同才有解，否则无解，所以开始要做是否有解的判别。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInversions</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 求逆序数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] != <span class="number">0</span> &amp;&amp; num[i] &gt; num[j])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSolution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; end)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 判断逆序数奇偶性来决定是否有解</span></span><br><span class="line">    <span class="keyword">int</span> inverStart, inverEnd;</span><br><span class="line">    inverStart = getInversions(start);</span><br><span class="line">    inverEnd = getInversions(end);</span><br><span class="line">    <span class="keyword">return</span> (inverStart % <span class="number">2</span> == inverEnd % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="宽度优先搜索（又称广度优先搜索），即-BFS"><a href="#宽度优先搜索（又称广度优先搜索），即-BFS" class="headerlink" title="宽度优先搜索（又称广度优先搜索），即 BFS"></a>宽度优先搜索（又称广度优先搜索），即 BFS</h1><p>首先每一次的九宫格当做一个状态，即状态类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">int</span> nowId, parentId;<span class="comment">// 自身 id 及父状态 id，用于输出路径</span></span><br><span class="line">    state(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> nowId, <span class="keyword">int</span> parentId)</span><br><span class="line">    &#123;<span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num = num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nowId = nowId;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parentId = parentId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> state &amp;now) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="comment">// 重载 == 运算符判断两个状态是否相等</span></span><br><span class="line">        <span class="keyword">return</span> isEqual(num, now.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] != end[i])</span><br><span class="line">        &#123;<span class="comment">// 只要有一个数字不同即不相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知 BFS 算法需要借助一个队列实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;state&gt; open;</span><br><span class="line"><span class="built_in">vector</span>&lt;state&gt; path;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; close;</span><br></pre></td></tr></table></figure><p><code>open</code>表即是状态队列，<code>path</code>表用于存储路径上的状态，<code>close</code>表用于判断一个状态是否被访问过。</p><p>BFS 算法函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; move = &#123;<span class="number">-1</span>, <span class="number">-3</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;<span class="comment">// 代表数字分别向左、上、右、下移动</span></span><br><span class="line">    open.push(state(start, id, id++));</span><br><span class="line">    <span class="keyword">while</span> (!open.empty())</span><br><span class="line">    &#123;<span class="comment">// 当 open 表非空时取队列头元素进行判断，并将生成的子状态加入队列尾部</span></span><br><span class="line">        state now = open.front();</span><br><span class="line">        open.pop();</span><br><span class="line">        path.push_back(now);</span><br><span class="line">        close[now.num] = <span class="literal">true</span>;<span class="comment">// 设置该状态已被访问</span></span><br><span class="line">        <span class="keyword">if</span> (isEqual(now.num, end))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> path.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> zeroL = zeroLocation(now.num);<span class="comment">// 找到数字 0 所在的的位置</span></span><br><span class="line">        <span class="keyword">int</span> newLocation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newLocation = zeroL + move[i];</span><br><span class="line">            <span class="keyword">if</span> (newLocation &gt; <span class="number">-1</span> &amp;&amp; newLocation &lt; <span class="number">9</span> </span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">2</span> &amp;&amp; zeroL == <span class="number">3</span>) </span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">3</span> &amp;&amp; zeroL == <span class="number">2</span>) </span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">5</span> &amp;&amp; zeroL == <span class="number">6</span>) </span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">6</span> &amp;&amp; zeroL == <span class="number">5</span>))</span><br><span class="line">            &#123;<span class="comment">// 判断数字移动后是否越界</span></span><br><span class="line">                swap(now.num[newLocation], now.num[zeroL]);<span class="comment">// 对数字进行移动</span></span><br><span class="line">                state newState = state(now.num, id++, now.nowId);</span><br><span class="line">                swap(now.num[newLocation], now.num[zeroL]);</span><br><span class="line">                <span class="keyword">if</span> (isEqual(newState.num, end))</span><br><span class="line">                &#123;</span><br><span class="line">                    path.push_back(newState);</span><br><span class="line">                    <span class="keyword">return</span> path.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!close.count(newState.num))</span><br><span class="line">                &#123;<span class="comment">// 若该状态不在 close 表中，即未被访问过</span></span><br><span class="line">                    open.push(newState);<span class="comment">// 新状态入队列</span></span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/zsgdyf/Git-For-Class/blob/master/ArtificialIntelligence/BFS.cpp" target="_blank" rel="noopener">完整源代码详见 GitHub</a></p><h1 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h1><p>启发式搜索 BFS 稍稍有些不同，主要在于启发式函数与启发式函数的选择。</p><p>启发式函数 </p><script type="math/tex; mode=display">f(x)=g(x)+h(x)</script><p>其中 <script type="math/tex">g(x)</script> 表示目标状态到当前状态的代价，用当前状态节点的深度表示。</p><p><script type="math/tex">h(x)</script> 表示当前状态到目标状态的估价，可以有很多选择，这里使用当前状态的位置与目标状态位置不同的数字个数表示。</p><p>这样每次就不必一次性扩展所有子节点，而是会尽量选择接近目标状态的节点去扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] != end[i])</span><br><span class="line">        &#123;</span><br><span class="line">            hX++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FX</span><span class="params">(state &amp;now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now.hX + now.gX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次<code>open</code>表就无需使用队列来实现了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;state&gt; open;</span><br><span class="line"><span class="built_in">vector</span>&lt;state&gt; path;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; close;</span><br></pre></td></tr></table></figure><p>每次只需要从<code>open</code>表中取出 <script type="math/tex">f(x)</script> 最小的状态节点进行子节点扩展即可。</p><p>启发式搜索主函数（大部分判断移动和扩展都与 BFS 算法相似）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AStar</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; move = &#123;<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    open.push_back(state(start, HX(start, end), <span class="number">0</span>, HX(start, end), id, id++));</span><br><span class="line">    <span class="keyword">while</span> (!open.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> min = min_element(open.begin(), open.end(), [](<span class="keyword">const</span> state &amp;x, <span class="keyword">const</span> state &amp;y)-&gt; <span class="keyword">bool</span> </span><br><span class="line">        &#123;<span class="comment">// 寻找 open 表中 f(x) 最小的状态</span></span><br><span class="line">            <span class="keyword">return</span> x.fX &lt; y.fX;</span><br><span class="line">        &#125;);</span><br><span class="line">        state now = *min;</span><br><span class="line">        open.erase(min);</span><br><span class="line">        path.push_back(now);</span><br><span class="line">        close[now.num] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (isEqual(now.num, end))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> now.gX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> zeroL = zeroLocation(now.num);</span><br><span class="line">        <span class="keyword">int</span> newLocation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newLocation = zeroL + move[i];</span><br><span class="line">            <span class="keyword">if</span> (newLocation &gt; <span class="number">-1</span> &amp;&amp; newLocation &lt; <span class="number">9</span> </span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">2</span> &amp;&amp; zeroL == <span class="number">3</span>) </span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">3</span> &amp;&amp; zeroL == <span class="number">2</span>)</span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">5</span> &amp;&amp; zeroL == <span class="number">6</span>)</span><br><span class="line">            &amp;&amp; !(newLocation == <span class="number">6</span> &amp;&amp; zeroL == <span class="number">5</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                swap(now.num[newLocation], now.num[zeroL]);</span><br><span class="line">                state newState = state(now.num, <span class="number">0</span>, now.gX + <span class="number">1</span>, HX(now.num, end), id++, now.nowId);</span><br><span class="line">                swap(now.num[newLocation], now.num[zeroL]);</span><br><span class="line">                newState.fX = FX(newState);</span><br><span class="line">                <span class="keyword">if</span> (isEqual(newState.num, end))</span><br><span class="line">                &#123;</span><br><span class="line">                    path.push_back(newState);</span><br><span class="line">                    <span class="keyword">return</span> newState.gX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!close.count(newState.num))</span><br><span class="line">                &#123;</span><br><span class="line">                    open.push_back(newState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/zsgdyf/Git-For-Class/blob/master/ArtificialIntelligence/AStar.cpp" target="_blank" rel="noopener">完整源代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于八数码问题，网上搜索一下就能有详细说明，在此不做赘述。&lt;/p&gt;
&lt;p&gt;简单点说就是将类似下图所示的状态&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;2&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;8&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;7&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;6&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;通过与空格进行交换，达到类似如下所示的状态&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;1&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;2&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;8&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;7&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;6&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;在这个算法里空格当做数字 0 处理。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="课程" scheme="https://zsgdyf.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://zsgdyf.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下好用的软件</title>
    <link href="https://zsgdyf.github.io/archives/7484639a.html"/>
    <id>https://zsgdyf.github.io/archives/7484639a.html</id>
    <published>2018-11-25T13:48:19.000Z</published>
    <updated>2020-05-16T08:27:50.675Z</updated>
    
    <content type="html"><![CDATA[<p>Windows 下一些好用的软件<br>自用，备份</p><a id="more"></a><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><ul><li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a><br>主题等 <a href="https://github.com/typora" target="_blank" rel="noopener">GitHub 支援</a></li></ul><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><ul><li><a href="https://picpick.app/zh/" target="_blank" rel="noopener">PicPick</a></li><li><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li><a href="https://www.listary.com/" target="_blank" rel="noopener">Listary</a></li><li><a href="http://www.wox.one/" target="_blank" rel="noopener">Wox</a><br>开源软件。<a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">GitHub 地址</a></li></ul><h2 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h2><ul><li><a href="https://cn.bandisoft.com/honeyview/" target="_blank" rel="noopener">Honeyview</a></li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ul><li><a href="http://cn.bandisoft.com/" target="_blank" rel="noopener">Bandizip</a></li></ul><h2 id="网速显示"><a href="#网速显示" class="headerlink" title="网速显示"></a>网速显示</h2><ul><li>TrafficMonitor<br>开源软件。<a href="https://github.com/zhongyang219/TrafficMonitor" target="_blank" rel="noopener">GitHub 地址</a></li></ul><h2 id="状态栏透明"><a href="#状态栏透明" class="headerlink" title="状态栏透明"></a>状态栏透明</h2><ul><li>TaskbarTool<br>个人作品<br>作者：浅陌兮。<br>联系方式：<a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x36;&#55;&#53;&#57;&#x30;&#x33;&#54;&#51;&#49;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x36;&#55;&#53;&#57;&#x30;&#x33;&#54;&#51;&#49;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a><br>更新地址：<a href="https://yun.baidu.com/s/1dFNAfpZ" target="_blank" rel="noopener">百度云</a>，密码：tpi2。</li></ul><h2 id="文件预览"><a href="#文件预览" class="headerlink" title="文件预览"></a>文件预览</h2><ul><li><a href="https://pooi.moe/QuickLook/" target="_blank" rel="noopener">QuickLook</a><br>开源软件。<a href="https://github.com/QL-Win/QuickLook" target="_blank" rel="noopener">GitHub 地址</a></li></ul><h2 id="应用卸载"><a href="#应用卸载" class="headerlink" title="应用卸载"></a>应用卸载</h2><ul><li><a href="https://geekuninstaller.com" target="_blank" rel="noopener">Geek Uninstaller</a></li></ul><h2 id="GIF-录制"><a href="#GIF-录制" class="headerlink" title="GIF 录制"></a>GIF 录制</h2><ul><li><a href="https://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a><br>开源软件。<a href="https://github.com/NickeManarin/ScreenToGif" target="_blank" rel="noopener">GitHub 地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows 下一些好用的软件&lt;br&gt;自用，备份&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zsgdyf.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="备份" scheme="https://zsgdyf.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
      <category term="Windows" scheme="https://zsgdyf.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下更改 Telegram Desktop 默认字体</title>
    <link href="https://zsgdyf.github.io/archives/fd45428c.html"/>
    <id>https://zsgdyf.github.io/archives/fd45428c.html</id>
    <published>2018-11-15T07:07:00.000Z</published>
    <updated>2020-05-16T08:27:50.675Z</updated>
    
    <content type="html"><![CDATA[<p>备个份，方便以后好找。</p><a id="more"></a><p>感谢作者 <a href="https://github.com/ysc3839" target="_blank" rel="noopener">ysc3839</a></p><p><a href="https://github.com/ysc3839/TGFont" target="_blank" rel="noopener">github 链接地址</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>下载 <code>TGFont.dll</code> 并重命名为 <code>winmm.dll</code>，然后放在 Telegram 的文件夹里。</p><p><a href="https://github.com/ysc3839/TGFont/releases" target="_blank" rel="noopener">下载地址</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>初次运行时会创建 <code>TGFont.json</code>。</p><p>将中文字体更改为微软雅黑，我的配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"fonts"</span>: &#123;</span><br><span class="line"><span class="attr">"SimSun"</span>: &#123;</span><br><span class="line"><span class="attr">"replace"</span>: <span class="string">"Microsoft YaHei UI"</span>,</span><br><span class="line"><span class="attr">"#size"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"#width"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"#weight"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"#italic"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"#underLine"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"#strikeOut"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"debug"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;备个份，方便以后好找。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zsgdyf.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="随笔" scheme="https://zsgdyf.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="备份" scheme="https://zsgdyf.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
      <category term="Windows" scheme="https://zsgdyf.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>C++ 统计单词出现次数</title>
    <link href="https://zsgdyf.github.io/archives/6dcb7056.html"/>
    <id>https://zsgdyf.github.io/archives/6dcb7056.html</id>
    <published>2018-10-02T15:50:32.000Z</published>
    <updated>2020-05-16T08:27:50.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>咱们云计算课程的第一次实验：给定一英文文本文件 data.dat，编写 C 程序，读取文件中的内容，统计文件中出现次数最多的三个单词，并给出这三个单词的出现次数，同时输出程序运行的时间。（注： 这里不区分单词大小写，例如， he 与 He 当做是同一个单词计数）</p><p>C 实在是不会用，直接用 C++ 好了……趴。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>思路其实并没有多复杂，第一反应就是用 map 了，用键值对存储单词及其对应的出现次数，然后按照键值对给 map 排序，最后输出出现次数排在前三位的单词及其次数。</p></li><li><p>由于 map 会区分单词大小写，即 HE，He，he，hE会被分开存储，于是就需要在输入单词之后将其都转化为小写，再存储进 map 里面。</p></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="包含的头文件"><a href="#包含的头文件" class="headerlink" title="包含的头文件"></a>包含的头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //cout 输出流</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt; //读取文件流 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; //控制输出格式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //存储单词</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; //用于排序</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //sort 排序算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; //计算程序运行时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //字符串操作</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; //过滤标点符号</span></span></span><br></pre></td></tr></table></figure><h2 id="map-的用法"><a href="#map-的用法" class="headerlink" title="map 的用法"></a>map 的用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; wordCount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;&gt; wordVector;</span><br><span class="line">    ifstream inFile;</span><br><span class="line">    inFile.open(<span class="string">"data.dat"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!inFile.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; word;</span><br><span class="line">        word = delePunct(word);</span><br><span class="line">        word = toLower(word);</span><br><span class="line">        wordCount[word]++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里使用<br><code>map&lt;string, size_t&gt; wordCount;</code><br>定义了一个名为<code>wordCount</code>的 <code>map</code>，其中第一个数据（关键字 <code>key</code>）为 <code>string</code> 类型，用于存储每一个单词，第二个数据（值 <code>value</code> ）为 <code>size_t</code>类型（C++ Primer 第五版 P375）。</p><p><em>注：在使用数组下标时，通常将其定义为  <code>size_t</code>类型，<code>size_t</code>是一种机器相关的无符号类型，它被设计得足够大 以便能够表示内存中任意对象的大小。（C++ Primer 第五版  P103）</em></p><p>接着通过<code>while</code>循环每次从<code>inFile</code>中输入一个单词，并将其去掉标点符号（<code>delePunct()</code>）和转换成小写（<code>toLower()</code>）之后，将其存入到<code>map</code>当中，并使其对应的值加 1 （若该单词不存在则会自动创建一个新的关键字）。</p><h2 id="去掉标点符号"><a href="#去掉标点符号" class="headerlink" title="去掉标点符号"></a>去掉标点符号</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">delePunct</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> outword;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ispunct</span>(word[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            outword = outword + word[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outword;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将单词全部转换成小写"><a href="#将单词全部转换成小写" class="headerlink" title="将单词全部转换成小写"></a>将单词全部转换成小写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">toLower</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        word[i] = <span class="built_in">tolower</span>(word[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-for-循环输出-map"><a href="#使用-for-循环输出-map" class="headerlink" title="使用 for 循环输出 map"></a>使用 for 循环输出 map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : wordCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(<span class="number">20</span>) &lt;&lt; w.first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; w.second </span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>)? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="将-map-按值排序并输出"><a href="#将-map-按值排序并输出" class="headerlink" title="将 map 按值排序并输出"></a>将 map 按值排序并输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortByValue</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; &amp;wordMap, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;&gt; &amp;wordVector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : wordMap)</span><br><span class="line">    &#123;</span><br><span class="line">        wordVector.push_back(make_pair(iter.first, iter.second));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(wordVector.begin(), wordVector.end(), compare);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = wordVector.begin(); iter &lt; (wordVector.begin() + <span class="number">3</span>); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; left &lt;&lt; setw(<span class="number">20</span>) &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; iter-&gt;second</span><br><span class="line">             &lt;&lt; ((iter-&gt;second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，C++ 语言中的 <code>map</code> 默认按照 <code>key</code> 排序，并且也没有内建按值（<code>value</code>）排序的函数，所以我们需要将 <code>map</code> 中存储的 <code>pair</code> 对象存放在一个新建的 <code>vector</code> 中，然后再使用 <code>vector</code> 中的 <code>sort</code> 函数对其进行排序。<br><em><code>vector</code> 使用的 <code>sort</code> 函数中第三个参数 <code>compare</code>：</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; &amp;x, <span class="keyword">const</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/zsgdyf/Git-For-Class/tree/master/CloudComputing" target="_blank" rel="noopener">完整源代码</a><br>（并附有 Java 版本）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;咱们云计算课程的第一次实验：给定一英文文本文件 data.dat，编写 C 程序，读取文件中的内容，统计文件中出现次数最多的三个单词，并给出这三个单词的出现次数，同时输出程序运行的时间。（注： 这里不区分单词大小写，例如， he 与 He 当做是同一个单词计数）&lt;/p&gt;
&lt;p&gt;C 实在是不会用，直接用 C++ 好了……趴。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://zsgdyf.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="课程" scheme="https://zsgdyf.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://zsgdyf.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-next 基础配置</title>
    <link href="https://zsgdyf.github.io/archives/31053b28.html"/>
    <id>https://zsgdyf.github.io/archives/31053b28.html</id>
    <published>2018-09-26T09:29:17.000Z</published>
    <updated>2020-05-16T08:51:33.461Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo-next 主题的配置文件位于<code>/themes/next/_config.yml</code>，<br>大部分情况下只需要修改这个文件即可。</p><a id="more"></a><h1 id="修改网站图标"><a href="#修改网站图标" class="headerlink" title="修改网站图标"></a>修改网站图标</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br></pre></td></tr></table></figure><p>将你想要更改的图标文件放在<code>/source/</code>目录（推荐）或者<code>hexo-site/themes/next/source/images/</code>目录替换同名文件即可。</p><h1 id="增加（或删除）“标签”、“分类”等"><a href="#增加（或删除）“标签”、“分类”等" class="headerlink" title="增加（或删除）“标签”、“分类”等"></a>增加（或删除）“标签”、“分类”等</h1><p>在网站所在文件夹执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>即可添加标签页面<br>（分类同理<code>hexo new page categories</code>）</p><p>对应 next 主题配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><h1 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: Friends</span><br><span class="line">links_layout: block</span><br><span class="line">#links_layout: inline</span><br><span class="line">links:</span><br><span class="line">   沚水的小窝: http://blog.zsakvo.cc/</span><br></pre></td></tr></table></figure><h1 id="设置自己头像"><a href="#设置自己头像" class="headerlink" title="设置自己头像"></a>设置自己头像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure><h1 id="侧边栏增加自己社交账号"><a href="#侧边栏增加自己社交账号" class="headerlink" title="侧边栏增加自己社交账号"></a>侧边栏增加自己社交账号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/zsgdyf || github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  Twitter: https://twitter.com/zsgdyf || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><h1 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h1><p>安装字数统计插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>然后打开主题配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line"> item_text: true</span><br><span class="line"> wordcount: true</span><br><span class="line"> min2read: false</span><br><span class="line"> totalcount: true</span><br><span class="line"> separated_meta: true</span><br></pre></td></tr></table></figure><p>打开 post.swig 文件，<code>/themes/next/layout/_macro/post.swig</code></p><p>找到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; wordcount(post.content) &#125;&#125;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; wordcount(post.content) &#125;&#125; 字</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>同理修改阅读时长，修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><h1 id="修改字体大小"><a href="#修改字体大小" class="headerlink" title="修改字体大小"></a>修改字体大小</h1><p>找到 base.styl 文件，<code>/themes/next/source/css/_variables/base.styl</code></p><p>找到如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Font size</span><br><span class="line">$font-size-base           = 16px</span><br><span class="line">$font-size-base           = unit(hexo-config(&apos;font.global.size&apos;), px) if hexo-config(&apos;font.global.size&apos;) is a &apos;unit&apos;</span><br><span class="line">$font-size-small          = $font-size-base - 2px</span><br><span class="line">$font-size-smaller        = $font-size-base - 4px</span><br><span class="line">$font-size-large          = $font-size-base + 2px</span><br><span class="line">$font-size-larger         = $font-size-base + 4px</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Headings font size</span><br><span class="line">$font-size-headings-step    = 2px</span><br><span class="line">$font-size-headings-base    = 25px</span><br><span class="line">$font-size-headings-base    = unit(hexo-config(&apos;font.headings.size&apos;), px) if hexo-config(&apos;font.headings.size&apos;) is a &apos;unit&apos;</span><br><span class="line">$font-size-headings-small   = $font-size-headings-base - $font-size-headings-step</span><br><span class="line">$font-size-headings-smaller = $font-size-headings-small - $font-size-headings-step</span><br><span class="line">$font-size-headings-large   = $font-size-headings-base + $font-size-headings-step</span><br><span class="line">$font-size-headings-larger  = $font-size-headings-large + $font-size-headings-step</span><br></pre></td></tr></table></figure><p>修改其中的<code>font-size-base</code>即可。</p><h1 id="增加站内搜索"><a href="#增加站内搜索" class="headerlink" title="增加站内搜索"></a>增加站内搜索</h1><p>在网站所在文件夹执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>添加搜索功能</p><p>接着修改主题配置文件为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo-next 主题的配置文件位于&lt;code&gt;/themes/next/_config.yml&lt;/code&gt;，&lt;br&gt;大部分情况下只需要修改这个文件即可。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zsgdyf.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://zsgdyf.github.io/tags/Hexo/"/>
    
      <category term="学习" scheme="https://zsgdyf.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>心血来潮</title>
    <link href="https://zsgdyf.github.io/archives/5be9a4c2.html"/>
    <id>https://zsgdyf.github.io/archives/5be9a4c2.html</id>
    <published>2018-09-26T08:32:44.000Z</published>
    <updated>2020-05-16T08:48:56.042Z</updated>
    
    <content type="html"><![CDATA[<p>心血来潮想画一张表</p><a id="more"></a><p><img src="/images/SQsheet.jpg" alt="呐，一张表" title="呐，一张表"></p><p>虽然不知道具体想要表示什么……<br>但总感觉应该就是这个样子的没错儿w</p><p><del>数据真的没有实际意义</del></p><p><del>数值都是咱瞎编的</del>（逃~）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;心血来潮想画一张表&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://zsgdyf.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://zsgdyf.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="https://zsgdyf.github.io/archives/77770c79.html"/>
    <id>https://zsgdyf.github.io/archives/77770c79.html</id>
    <published>2018-09-25T00:49:29.000Z</published>
    <updated>2020-05-16T08:49:50.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h1><a id="more"></a><p><del>梦开始的地方</del></p><p>第一篇，还是老规矩，HelloWorld~</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="380" height="126" src="//music.163.com/outchain/player?type=2&id=446944042&auto=0&height=106"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一切的开始&quot;&gt;&lt;a href=&quot;#一切的开始&quot; class=&quot;headerlink&quot; title=&quot;一切的开始&quot;&gt;&lt;/a&gt;一切的开始&lt;/h1&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://zsgdyf.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://zsgdyf.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
