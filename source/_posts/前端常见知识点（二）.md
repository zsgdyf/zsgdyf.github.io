---
title: 前端常见知识点（二）
tags:
  - 学习
  - 前端
categories:
  - 学习
abbrlink: b0ec6ec8
date: 2019-03-06 17:43:35
---

# 继承

## 原型链

根据「红宝书」中的描述，**原型链**是实现继承的主要方法。其原理是利用**原型**让一个引用类型继承另一个引用类型的属性和方法。

<!--more-->

例如：

```javascript
function Father () {
    this.name = 'F'
}
Father.prototype.getFatherName = function () {
    return this.name
}
function Son () {
    this.sonname = "S"
}
// 创建 Father 实例，并将其赋给 Son.prototype
Son.prototype = new Father()
Son.prototype.getSonName = function () {
    return this.sonname
}
var son1 = new Son()
console.log(son1.getFatherName()) // F
```

上述代码实现了`Son`继承`Father`，其本质是重写`Son`的原型对象，并以`Father`的实例代之，这样，原本存在于`Father`实例中的属性和方法，现在也存在于`Son.prototype`中了。

同时的，**所有函数的默认原型都是`Object`的实例**，即可以看做是

```js
Father.prototype = new Object()
```

这样我们就有了「`Son`的原型对象中包含着指向`Father`原型的指针，`Father`的原型对象中又包含着指向`Object`原型的指针」，如此递进，形成了实例与原型的链，这就是原型链的基本概念。

但是所谓的「原型对象」又是什么呢？

## 原型对象

「红宝书」中说

> 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则来为该函数创建一个`prototype`属性，这个属性指向函数的原型对象。
>
> 并且在默认情况下，所有的原型对象都会自动获得一个`constructor`（构造函数）属性，这个属性是一个指向`prototype`属性所在函数的指针。

例如：

```js
function Father () {
    this.name = 'F'
}
Father.prototype.constructor // function Father()
```

倘若我们调用构造函数创建一个新实例：

```js
var father = new Father()
```

那么该实例的内部就会包含一个指针（内部属性），指向构造函数的原型对象。

在某些地方（Chrome，Firefox），我们可以这样访问它：

``` js
father.__proto__ // Father.prototype
father.__proto__.constructor // function Father()
```

并且，这个连接存在于实例与构造函数的**原型对象**之间，而不是实例与构造函数之间。